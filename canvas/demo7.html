<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>英语</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>

<body>
  <script src="phaser.min.js"></script>
  <script type="text/javascript">

    let word = [{ "word": "commit", "point": "" }]

    let data = [{ "point": "3,0", "word": "c", "show": false }, { "point": "2,1", "word": "c", "show": true },
    { "point": "3,1", "word": "o", "show": false }, { "point": "4,1", "word": "l", "show": false },
    { "point": "5,1", "word": "u", "show": true }, { "point": "6,1", "word": "m", "show": false },
    { "point": "7,1", "word": "n", "show": true }, { "point": "8,1", "word": "s", "show": true },
    { "point": "1,2", "word": "r", "show": false }, { "point": "3,2", "word": "m", "show": true },
    { "point": "1,3", "word": "e", "show": false }, { "point": "3,3", "word": "m", "show": true },
    { "point": "0,4", "word": "s", "show": true }, { "point": "1,4", "word": "p", "show": false },
    { "point": "2,4", "word": "r", "show": true }, { "point": "3,4", "word": "i", "show": false },
    { "point": "4,4", "word": "n", "show": true }, { "point": "5,4", "word": "g", "show": true },
    { "point": "1,5", "word": "o", "show": true }, { "point": "3,5", "word": "t", "show": false },
    { "point": "4,5", "word": "a", "show": true }, { "point": "5,5", "word": "b", "show": false },
    { "point": "6,5", "word": "l", "show": true }, { "point": "7,5", "word": "e", "show": true },
    { "point": "1,6", "word": "r", "show": true }, { "point": "1,7", "word": "t", "show": true },
    { "point": "2,7", "word": "h", "show": true }, { "point": "3,7", "word": "a", "show": false },
    { "point": "4,7", "word": "n", "show": false }, { "point": "5,7", "word": "k", "show": false },
    { "point": "6,7", "word": "s", "show": true }];


    data = [{ "x": 3, "y": 0, "word": "c", "show": false }, { "x": 2, "y": 1, "word": "c", "show": true },
    { "x": 3, "y": 1, "word": "o", "show": false }, { "x": 4, "y": 1, "word": "l", "show": false },
    { "x": 5, "y": 1, "word": "u", "show": true }, { "x": 6, "y": 1, "word": "m", "show": false },
    { "x": 7, "y": 1, "word": "n", "show": true }, { "x": 8, "y": 1, "word": "s", "show": true },
    { "x": 1, "y": 2, "word": "r", "show": false }, { "x": 3, "y": 2, "word": "m", "show": true },
    { "x": 1, "y": 3, "word": "e", "show": false }, { "x": 3, "y": 3, "word": "m", "show": true },
    { "x": 0, "y": 4, "word": "s", "show": true }, { "x": 1, "y": 4, "word": "p", "show": false },
    { "x": 2, "y": 4, "word": "r", "show": true }, { "x": 3, "y": 4, "word": "i", "show": false },
    { "x": 4, "y": 4, "word": "n", "show": true }, { "x": 5, "y": 4, "word": "g", "show": true },
    { "x": 1, "y": 5, "word": "o", "show": true }, { "x": 3, "y": 5, "word": "t", "show": false },
    { "x": 4, "y": 5, "word": "a", "show": true }, { "x": 5, "y": 5, "word": "b", "show": false },
    { "x": 6, "y": 5, "word": "l", "show": true }, { "x": 7, "y": 5, "word": "e", "show": true },
    { "x": 1, "y": 6, "word": "r", "show": true }, { "x": 1, "y": 7, "word": "t", "show": true },
    { "x": 2, "y": 7, "word": "h", "show": true }, { "x": 3, "y": 7, "word": "a", "show": false },
    { "x": 4, "y": 7, "word": "n", "show": false }, { "x": 5, "y": 7, "word": "k", "show": false },
    { "x": 6, "y": 7, "word": "s", "show": true }];


    // 待选取的字母
    let data2 = [];
    for (var i = 0, len = data.length; i < len; i++) {
      if (!data[i].show) {
        data2.push(data[i])
      }
    }

    // 方格的个数
    let cellNum = 9;

    // 生成二维数组
    // var array = [];
    // for (var i = 0; i < cellNum; i++) {
    //   array[i] = [];
    //   for (var j = 0; j < cellNum; j++) {
    //     array[i][j] = {};

    //     if (temp && temp.point == (j + "," + i)) {
    //       array[i][j].visible = true;
    //       array[i][j].word = temp.word;
    //       array[i][j].show = temp.show;
    //       array[i][j].point = temp.point;

    //       temp = data.shift();
    //     } else {
    //       // array[i][j].visible = false;
    //       array[i][j].visible = true;
    //     }
    //   }
    // }
    // console.log('二维数组为：')
    // console.log(array)


    // 各种变量定义
    let gameWidth = window.innerWidth;
    let gameHeight = window.innerHeight;

    // 每个方格的宽度
    let cellWidth;
    // 绘制方格的开始坐标点 
    var startX, startY, pointX;

    // 默认的方格
    var cellGroup = [];
    // 选中状态的方格
    var cellGroupBack = [];

    // 显示单词的数组
    var wordGroup = [];

    // 待填入的字母方格
    var blockGroup = [];
    // 待填入的字母数组
    var letterGroup = [];

    // 主要区域的开始坐标
    let mainDivX = 10, mainDivY = 100;


    var game = new Phaser.Game(gameWidth, gameHeight, Phaser.CANVAS, '', {
      preload: preload,
      create: create,
      update: update
    })

    function preload() {

      // 背景颜色
      game.stage.backgroundColor = '#CECECE';

      // 计算中间区域的宽度，两边留10像素 
      // 绘制方格 展示方格的区域宽度 mainWidth
      var mainWidth = gameWidth - 10 * 2;

      //新建图形，第一个参数为x轴位置，第二个参数为y轴位置
      const graphicObject = game.add.graphics(mainDivX, mainDivY);
      //画一个矩形
      graphicObject.beginFill(0xB9B9B9);  //设置矩形的颜色
      // 暂定正方形
      graphicObject.drawRect(0, 0, mainWidth, mainWidth);   //设置矩形的x,y,width,height

      // 计算方格的宽度
      // 方格个数 cellNum
      var width_1 = mainWidth - cellNum * 3; // 再减去方格之间3像素的间隔
      var width_2 = parseInt(width_1 / cellNum) // 方格的宽度，取整操作
      console.info("每个方格的宽度： " + width_2)
      // 计算剩下的边宽度
      var width_3 = width_1 - width_2 * cellNum;
      width_3 = width_3 / 2 // 平分剩余的宽度，把它当做起点

      // console.log('平分剩余的宽度 ' + width_3)

      startX = mainDivX + width_3, pointX = startX;
      startY = mainDivY + width_3;

      cellWidth = width_2;
    }


    function create() {

      var i = 0;

      var temp = data.shift();

      for (var y = 0; y < cellNum; y++) {

        if (y > 0) {
          // Y坐标开始叠加，主要要算上间隔的3像素
          startY = startY + 3 + cellWidth
          // X坐标要重新开始
          startX = pointX
        }

        for (var x = 0; x < cellNum; x++) {

          if (temp == undefined) {
            break;
          }

          if (x > 0) {
            // 同理，X坐标也要叠加
            startX = startX + 3 + cellWidth
          }

          //
          if (temp.x == x && temp.y == y) {

          } else {
            continue;
          }

          var show = temp.show

          var letter = '';
          if (show) {
            letter = temp.word
          }

          // 生成默认样式的方块
          var cellMapData = createBitmapData(1, "#000000", show);
          // 生成选中样式的方块
          var cellBackMapData = createBitmapData(4, "#cc0000", false);



          cellGroup[i] = game.add.sprite(startX, startY, cellMapData);
          cellGroup[i].inputEnabled = true;

          cellGroup[i].data = {
            x: x,
            y: y,
            index: i,
            data: temp
          };

          cellGroupBack[i] = game.add.sprite(startX, startY, cellBackMapData);
          // cellGroupBack[i].alpha = 0 // 透明度
          cellGroupBack[i].visible = false // 是否显示
          cellGroupBack[i].inputEnabled = true;

          cellGroupBack[i].data = {
            x: x,
            y: y,
            index: i,
            data: temp
          };


          console.log(letter)

          // 创建字母
          var word = createText(startX, startY, letter, '#cc0000')

          wordGroup[i] = word;

          temp = data.shift();
          i++;

        }
      }


      // 随机打乱顺序
      data2.sort(function (a, b) { return Math.random() > .5 ? -1 : 1 })

      // 下方显示字母的坐标
      var wordX = pointX;
      var wordY = startY + cellWidth + (cellWidth * 2);

      i = 0;

      // 定义临时变量，存储需要显示的方格坐标
      var tempWord = data2.shift();

      for (var y = 0; y < cellNum; y++) {
        if (y > 0) {
          // Y坐标开始叠加，主要要算上间隔的3像素
          wordY = wordY + 3 + cellWidth
          // X坐标要重新开始
          wordX = pointX
        }

        for (var x = 0; x < cellNum; x++) {

          if (tempWord == undefined) {
            break;
          }

          if (x > 0) {
            // 同理，X坐标也要叠加
            wordX = wordX + 3 + cellWidth
          }

          // 生成默认样式的方块
          var mapData = createBitmapData(1, "#000000", false);

          blockGroup[i] = game.add.sprite(wordX, wordY, mapData);
          blockGroup[i].inputEnabled = true;

          blockGroup[i].data = {
            x: x,
            y: y,
            index: i,
            data: tempWord
          };

          var letter = tempWord.word;

          var word = createText(wordX, wordY, letter, '#cc0000')

          letterGroup[i] = word;

          tempWord = data2.shift();
          i++;
        }
      }

      // console.info(cellGroup)
      cellGroup[0].visible = false
      cellGroupBack[0].visible = true
    }



    function update() {

      // 添加选中事件
      for (var i = 0; i < cellGroup.length; i++) {
        // 如果不是待填字母不需要绑定事件
        if (!cellGroup[i].data.data.show) {
          cellGroup[i].events.onInputDown.add(onDown2, this);
        }
      }

      // 选中框也添加事件
      for (var i = 0; i < cellGroupBack.length; i++) {
        if (!cellGroup[i].data.data.show) {
          cellGroupBack[i].events.onInputDown.add(onDown2, this);
        }
      }

      // 待填字母方块添加事件
      for (var i = 0; i < blockGroup.length; i++) {
        blockGroup[i].events.onInputDown.add(onDown3, this);
      }

    }

    // 临时变量
    var chooseCellIndex = 0;

    function onDown2(cell) {
      console.log(cell)
      // console.log(cell.data)
      // console.log(cell.data.index)

      // 选中的方格
      var newIndex = cell.data.index

      // 如果点击的方块和原先的一样则不需要改变方块样式
      if (newIndex == chooseCellIndex) {

      } else {
        // 原先的取消选中状态
        // cellGroup[chooseCellIndex].alpha = 1
        cellGroup[chooseCellIndex].visible = true

        // cellGroupBack[chooseCellIndex].alpha = 0
        cellGroupBack[chooseCellIndex].visible = false

        // 这次选择的添加选中状态
        // cellGroup[cell.data.index].alpha = 0
        cellGroup[newIndex].visible = false

        // cellGroupBack[cell.data.index].alpha = 1
        cellGroupBack[newIndex].visible = true
      }

      // 获取该方块是否已经有字母了，有则需要清除还原，没有则不需要操作
      var letterIndex = cellGroup[newIndex].data.letterIndex
      // console.log(letterIndex) // 注意 0 也是false
      if (letterIndex != undefined) {
        blockGroup[letterIndex].visible = true
        letterGroup[letterIndex].visible = true

        cellGroup[newIndex].data.letterIndex = undefined
        wordGroup[newIndex].setText("", true)
      }

      // 修改变量为最新值
      chooseCellIndex = newIndex

    }



    function onDown3(letter) {
      console.log(letter)

      var letterIndex = cellGroup[chooseCellIndex].data.letterIndex
      // 位置有字母则需要把原先的还原
      if (letterIndex != undefined) {
        blockGroup[letterIndex].visible = true
        letterGroup[letterIndex].visible = true
      }

      // 隐藏点击的字母
      letter.visible = false;
      var index = letter.data.index;
      letterGroup[index].visible = false

      // 把点击的字母放到选中的方块上
      wordGroup[chooseCellIndex].setText(letterGroup[index].text, true)
      // 修改选中方块的字母下标
      cellGroup[chooseCellIndex].data.letterIndex = index

    }


    /**
      创建 BitmapData
      lineWidth 线宽
      strokeStyle 边框样式
      show  是否填充
    */

    function createBitmapData(lineWidth, strokeStyle, show) {
      var mapData = game.add.bitmapData(cellWidth, cellWidth);

      mapData.ctx.beginPath();
      mapData.ctx.lineWidth = lineWidth
      mapData.ctx.strokeStyle = strokeStyle
      mapData.ctx.strokeRect(0, 0, cellWidth, cellWidth)

      // 填充
      if (show) {
        mapData.ctx.rect(lineWidth, lineWidth, cellWidth - (lineWidth * 2), cellWidth - (lineWidth * 2));
        mapData.ctx.fillStyle = '#aaaaaa';
        mapData.ctx.fill();
      }

      mapData.ctx.closePath();

      return mapData;
    }

    /**
      创建字母
      x 
      y
      text 显示文本
      fontColor  颜色
    */
    function createText(x, y, text, fontColor) {
      var word = game.add.text(x, y, text, {
        font: "sans-serif",
        fontSize: '20px',
        fill: fontColor,
        boundsAlignH: "center",
        boundsAlignV: "middle",
      });

      word.setTextBounds(0, 2, cellWidth, cellWidth);

      return word;
    }


  </script>
</body>

</html>